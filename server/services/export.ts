import { supabase } from '../../lib/supabase';
import type { Document, Node } from '../../shared/schema';

export class ExportService {
  async generateShareLink(documentId: string, userId: string): Promise<string> {
    // Verify user owns the document
    const { data: document, error } = await supabase
      .from('documents')
      .select('*')
      .eq('id', documentId)
      .eq('user_id', userId)
      .single();

    if (error || !document) {
      throw new Error('Document not found or access denied');
    }

    // Generate share token
    const shareToken = this.generateShareToken();
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // Expire in 7 days

    // Store share record (using existing collab_sessions table)
    const { error: insertError } = await supabase
      .from('collab_sessions')
      .insert({
        mindmap_id: documentId,
        session_token: shareToken
      });

    if (insertError) {
      throw new Error('Failed to create share link');
    }

    return shareToken;
  }

  async getSharedDocument(shareToken: string): Promise<{ document: Document; nodes: Node[] } | null> {
    // Find document by share token
    const { data: session, error } = await supabase
      .from('collab_sessions')
      .select('mindmap_id')
      .eq('session_token', shareToken)
      .single();

    if (error || !session) {
      return null;
    }

    // Get document and nodes
    const [documentResult, nodesResult] = await Promise.all([
      supabase
        .from('documents')
        .select('*')
        .eq('id', session.mindmap_id)
        .single(),
      supabase
        .from('nodes')
        .select('*')
        .eq('document_id', session.mindmap_id)
        .order('level', { ascending: true })
    ]);

    if (documentResult.error || !documentResult.data) {
      return null;
    }

    return {
      document: documentResult.data,
      nodes: nodesResult.data || []
    };
  }

  async exportMarkdown(documentId: string, userId: string): Promise<string> {
    // Verify ownership
    const { data: document } = await supabase
      .from('documents')
      .select('*')
      .eq('id', documentId)
      .eq('user_id', userId)
      .single();

    if (!document) {
      throw new Error('Document not found');
    }

    // Get nodes
    const { data: nodes } = await supabase
      .from('nodes')
      .select('*')
      .eq('document_id', documentId)
      .order('level', { ascending: true });

    if (!nodes) {
      throw new Error('No mind map data found');
    }

    // Generate markdown
    let markdown = `# ${document.title}\n\n`;
    markdown += `*Generated by Mindflow on ${new Date().toLocaleDateString()}*\n\n`;

    // Group nodes by level
    const topicNodes = nodes.filter(n => n.level === 0);
    const conceptNodes = nodes.filter(n => n.level === 1);
    const leafNodes = nodes.filter(n => n.level === 2);

    topicNodes.forEach(topic => {
      markdown += `## ${topic.title}\n\n`;
      if (topic.summary) {
        markdown += `${topic.summary}\n\n`;
      }

      // Find concepts under this topic
      const relatedConcepts = conceptNodes.filter(c => c.parent_id === topic.id);
      relatedConcepts.forEach(concept => {
        markdown += `### ${concept.title}\n\n`;
        if (concept.summary) {
          markdown += `${concept.summary}\n\n`;
        }

        // Find leaves under this concept
        const relatedLeaves = leafNodes.filter(l => l.parent_id === concept.id);
        relatedLeaves.forEach(leaf => {
          markdown += `- **${leaf.title}**: ${leaf.summary || ''}\n`;
        });
        markdown += '\n';
      });
    });

    return markdown;
  }

  private generateShareToken(): string {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  }
}

export const exportService = new ExportService();